{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ticktock Simple Python code metering library. ticktock is a minimalist library to profile Python code, it displays timing of code snippets periodically. Installation \u00b6 ticktock is available in the PyPI repository: pip install py-ticktock Quick start \u00b6 Anywhere in your code you can use tick to start a clock, and tock to register the end of the snippet you want to time: from ticktock import tick clock = tick () # do some work clock . tock () This will print \u23f1\ufe0f [3-5] 1ms count=1 Indicating that lines 3-5 take <1ms to run. If the timed snippet is called multiple times (for example within a loop), measured times will be aggregated and printed periodically (every 2 seconds by default). As a result, the following code: from ticktock import tick for _ in range ( 1000 ): clock = tick () # do some work clock . tock () Will output: \u23f1\ufe0f [4-6] 1ms count=1000 Customize rendering \u00b6 ticktock allows you to print out periodical information about the time tracked by its different clocks. By default, it is printed to stdout , but it is also possible to send log messages (see Rendering ).","title":"Home"},{"location":"#installation","text":"ticktock is available in the PyPI repository: pip install py-ticktock","title":"Installation"},{"location":"#quick-start","text":"Anywhere in your code you can use tick to start a clock, and tock to register the end of the snippet you want to time: from ticktock import tick clock = tick () # do some work clock . tock () This will print \u23f1\ufe0f [3-5] 1ms count=1 Indicating that lines 3-5 take <1ms to run. If the timed snippet is called multiple times (for example within a loop), measured times will be aggregated and printed periodically (every 2 seconds by default). As a result, the following code: from ticktock import tick for _ in range ( 1000 ): clock = tick () # do some work clock . tock () Will output: \u23f1\ufe0f [4-6] 1ms count=1000","title":"Quick start"},{"location":"#customize-rendering","text":"ticktock allows you to print out periodical information about the time tracked by its different clocks. By default, it is printed to stdout , but it is also possible to send log messages (see Rendering ).","title":"Customize rendering"},{"location":"clocks/","text":"The most important objects in ticktock are clocks, which record timing. Clocks \u00b6 You can define a Clock directly, and use its tick and tock methods: from ticktock.timer import Clock clock = Clock () clock . tick () clock . tock () This allows one to explicitly set the name of the clock: clock = Clock ( \"some_name\" ) Or its parent ClockCollection : clock = Clock ( \"some_name\" , collection = my_collection ) tick and tock recording \u00b6 Whenever a Clock is created, and when tock is called, ticktock will inspect the calling frame to determine which line in the code is being run. This allows one to redefine and discard clocks . For example, the following code creates and tracks two separate clocks : one starting at line 3, and finishing at line 4, and the other one starting at line 6 and finishing at line 7. from ticktock import tick clock = tick () clock . tock () clock = tick () clock . tock () timer function \u00b6 It is possible to change the timer function of a clock (which defaults to timing.perf_counter_ns ). When called without arguments, the timer function should return a measure of the current time in nanoseconds: clock = Clock ( timer = my_timer ) Clock with multiple tock calls \u00b6 A Clock can measure times between a single call to tick and multiple tock : everytime tick is called it is reset, and intervals are measured between this tick and all the possible tock s. For example, in this snippet, the clock will track the timing between tick and first tock as well as between tick and second_tock : from ticktock.timer import Clock clock = Clock ( name = \"tick\" ) clock . tick () clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" ) On the other hand, when tick is called, the timer is reset, and as a result the first call to tick below is discarded: from ticktock.timer import Clock clock = Clock () clock . tick () # will be disregarded clock . tick () # resets the clock clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" ) Aggregate times attribute \u00b6 The Clock object maintains a list of dataclasses with the current values of the last measured times for each of the Clock 's tock s in Clock.aggregate_times . Each item in the list has the following attributes, that are updated everytime a tock is performed on the clock. All time values are in nanoseconds: tock_name: str the name of the tock n_periods: int the number of measured tocks avg_time_ns: float the running average measured time std_time_ns: float = 0 the running standard deviation min_time_ns: float and max_time_ns: float the running extrema last_tick_time_ns: float the last time this was tick ed last_tock_time_ns: float the last time this was tock ed last_time_ns: float the last measured time","title":"Clocks"},{"location":"clocks/#clocks","text":"You can define a Clock directly, and use its tick and tock methods: from ticktock.timer import Clock clock = Clock () clock . tick () clock . tock () This allows one to explicitly set the name of the clock: clock = Clock ( \"some_name\" ) Or its parent ClockCollection : clock = Clock ( \"some_name\" , collection = my_collection )","title":"Clocks"},{"location":"clocks/#tick-and-tock-recording","text":"Whenever a Clock is created, and when tock is called, ticktock will inspect the calling frame to determine which line in the code is being run. This allows one to redefine and discard clocks . For example, the following code creates and tracks two separate clocks : one starting at line 3, and finishing at line 4, and the other one starting at line 6 and finishing at line 7. from ticktock import tick clock = tick () clock . tock () clock = tick () clock . tock ()","title":"tick and tock recording"},{"location":"clocks/#timer-function","text":"It is possible to change the timer function of a clock (which defaults to timing.perf_counter_ns ). When called without arguments, the timer function should return a measure of the current time in nanoseconds: clock = Clock ( timer = my_timer )","title":"timer function"},{"location":"clocks/#clock-with-multiple-tock-calls","text":"A Clock can measure times between a single call to tick and multiple tock : everytime tick is called it is reset, and intervals are measured between this tick and all the possible tock s. For example, in this snippet, the clock will track the timing between tick and first tock as well as between tick and second_tock : from ticktock.timer import Clock clock = Clock ( name = \"tick\" ) clock . tick () clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" ) On the other hand, when tick is called, the timer is reset, and as a result the first call to tick below is discarded: from ticktock.timer import Clock clock = Clock () clock . tick () # will be disregarded clock . tick () # resets the clock clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" )","title":"Clock with multiple tock calls"},{"location":"clocks/#aggregate-times-attribute","text":"The Clock object maintains a list of dataclasses with the current values of the last measured times for each of the Clock 's tock s in Clock.aggregate_times . Each item in the list has the following attributes, that are updated everytime a tock is performed on the clock. All time values are in nanoseconds: tock_name: str the name of the tock n_periods: int the number of measured tocks avg_time_ns: float the running average measured time std_time_ns: float = 0 the running standard deviation min_time_ns: float and max_time_ns: float the running extrema last_tick_time_ns: float the last time this was tick ed last_tock_time_ns: float the last time this was tock ed last_time_ns: float the last measured time","title":"Aggregate times attribute"},{"location":"collection/","text":"Collection \u00b6 ticks and tocks are recorded in a globally defined ClockCollection defined as ticktock.timer._DEFAULT_COLLECTION . It is possible to create a different ClockCollection and use it for your ticks and tocks as so: from ticktock.timer import ClockCollection collection = ClockCollection () tick ( collection = collection ) tock ( collection = collection ) The clock collection keeps track of all the clocks with their unique ids in collection.clocks , as well as deals with the rendering. Rendering period \u00b6 ticktock renders timing information on a fixed schedule with a given period . Update the period (in seconds) of the default collection to make it render more or less often: from ticktock.timer import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( period = 10 ) set_collection ( collection = collection )","title":"Collection"},{"location":"collection/#collection","text":"ticks and tocks are recorded in a globally defined ClockCollection defined as ticktock.timer._DEFAULT_COLLECTION . It is possible to create a different ClockCollection and use it for your ticks and tocks as so: from ticktock.timer import ClockCollection collection = ClockCollection () tick ( collection = collection ) tock ( collection = collection ) The clock collection keeps track of all the clocks with their unique ids in collection.clocks , as well as deals with the rendering.","title":"Collection"},{"location":"collection/#rendering-period","text":"ticktock renders timing information on a fixed schedule with a given period . Update the period (in seconds) of the default collection to make it render more or less often: from ticktock.timer import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( period = 10 ) set_collection ( collection = collection )","title":"Rendering period"},{"location":"customize/","text":"ticktock defaults to writing clock times to sys.stderr . It is possible to change the renderer used , which is useful if you want to customize the output, or send log messages. Changing format \u00b6 It is possible to change the output of ticktock clocks by changing the format string. Setting the format string \u00b6 The format string is a regular Python format string describing the desired output. Set the format string for the current default clock using set_format . For example, to print the minimum and maximum times of a clock, one could write: from ticktock import set_format set_format ( \" {min} < {mean} < {max} \" ) Equivalently, to globally set the format string, set the TICKTOCK_DEFAULT_FORMAT environment variable. Format string keys \u00b6 The keys in the format string have to be amongst the available attributes, and will be replaced by their value at render. Keys are of two distinct types, time keys and normal keys. Time keys will be replaced by a string representing the timing value with its unit attached: mean : the average of all past time intervals std : the standard deviation of all past time intervals min : the minimum measured time max : the maximum measured time last : the last measured time count : the numer of intervals measured. Normal keys have properties related to the position of the tick or tock: tick_name : the tick name if set when calling tick , otherwise equal to {tick_filename}:{tick_line} tock_name : the tock name if set when calling tock , otherwise equal to {tock_line} tick_line : the line at which tick was called in your code tock_line : the line at which tock was called in your code tick_filename : the name of the file in which tick was called tock_filename : the name of the file in which tock was called In addition, two special cased formats are accepted too: short with just the average time and the count \"\u23f1\ufe0f [ {tick_name} - {tock_name} ] {mean} count= {count} \" long corresponding to \"\u23f1\ufe0f [ {tick_name} - {tock_name} ] {mean} ( {std} std) min= {min} max= {max} count= {count} last= {last} \" Units \u00b6 By default, ticktock renders two unit levels such that 1.3 seconds will be written as 1s300ms , or 1 day and two hours and 50 minuts will be written as 1d2h . If you need more precision, you can also set the number of units you want displayed using the max_terms keyword in set_format as so: from ticktock import set_format set_format ( max_terms = 3 ) Raw time fields \u00b6 You can access the raw (floating point) values of the time aggregates as keys in the format string as well. These are all recorded in nanoseconds (unless you specified a different timer function): avg_time_ns :the average of all past time intervals std_time_ns : the standard deviation of all past time intervals min_time_ns : the minimum measured time max_time_ns : the maximum measured time last_time_ns : the last measured time Updated lines \u00b6 By default, ticktock attempts to update the last clock lines it has displayed with the new values. However, it can be undesirable in some instandes: - it can fail if other things are being written to the stream (e.g. using print in the code, or using tqdm ), or delete printed messages - it uses ASCII contol chars, which may be unwelcome if you are writing to a file If you want ticktock to write all clocks sequentially, without attempting to update previously renderered lines, set the format with no_update=True : from ticktock import set_format set_format ( no_update = True ) Change rendering period \u00b6 By default, ticktock renders clocks with a fixed period of two seconds. This can be changed globally by using set_period : from ticktock import tick set_period ( 1 ) Internally, ticktock will render all clocks whenever the period is elapsed, and a clock's tock was called. In addition to this, rendering also occurs: at the first tock of any clock when the program exits Enabling or disabling clocks \u00b6 It is possible to disable ticktock clocks: when disabled, the intervals between ticks and tocks are no longer recorded, and will not be rendered either. With an environment variable \u00b6 Set the TICKTOCK_DISABLE environment variable to disable all clocks and their rendering. With enable/disable \u00b6 ticktock also provide functions to enable or disable all clocks (and rendering): from ticktock import tick , enable , disable def some_function (): t = tick () pass t . tock () # This call will be timed and collected some_function () disable () # This call will NOT be timed some_function () enable () # This call will be timed again some_function () Warn enable and disable act on the current default ClockCollection (as set by set_collection ) Disabling a Clock vs. disabling a ClockCollection \u00b6 Warn This is an advanced topic, and should not occur unless you set the enabled/disabled state of Clock objects directly. Both Clock and ClockCollection objects can be enabled or disabled independently via their enable / disable methods. This can be misleading if a Clock 's state does not match its ClockCollection state. Simply put, here are the gotchas: a disabled Clock will not record any timing information, but if its ClockCollection is enabled, its state will be rendered disabling and enabling a ClockCollection will set the state of all of the Clock s that are currently attached to it disabling a clock does not disable its ClockCollection","title":"Customize output"},{"location":"customize/#changing-format","text":"It is possible to change the output of ticktock clocks by changing the format string.","title":"Changing format"},{"location":"customize/#setting-the-format-string","text":"The format string is a regular Python format string describing the desired output. Set the format string for the current default clock using set_format . For example, to print the minimum and maximum times of a clock, one could write: from ticktock import set_format set_format ( \" {min} < {mean} < {max} \" ) Equivalently, to globally set the format string, set the TICKTOCK_DEFAULT_FORMAT environment variable.","title":"Setting the format string"},{"location":"customize/#format-string-keys","text":"The keys in the format string have to be amongst the available attributes, and will be replaced by their value at render. Keys are of two distinct types, time keys and normal keys. Time keys will be replaced by a string representing the timing value with its unit attached: mean : the average of all past time intervals std : the standard deviation of all past time intervals min : the minimum measured time max : the maximum measured time last : the last measured time count : the numer of intervals measured. Normal keys have properties related to the position of the tick or tock: tick_name : the tick name if set when calling tick , otherwise equal to {tick_filename}:{tick_line} tock_name : the tock name if set when calling tock , otherwise equal to {tock_line} tick_line : the line at which tick was called in your code tock_line : the line at which tock was called in your code tick_filename : the name of the file in which tick was called tock_filename : the name of the file in which tock was called In addition, two special cased formats are accepted too: short with just the average time and the count \"\u23f1\ufe0f [ {tick_name} - {tock_name} ] {mean} count= {count} \" long corresponding to \"\u23f1\ufe0f [ {tick_name} - {tock_name} ] {mean} ( {std} std) min= {min} max= {max} count= {count} last= {last} \"","title":"Format string keys"},{"location":"customize/#units","text":"By default, ticktock renders two unit levels such that 1.3 seconds will be written as 1s300ms , or 1 day and two hours and 50 minuts will be written as 1d2h . If you need more precision, you can also set the number of units you want displayed using the max_terms keyword in set_format as so: from ticktock import set_format set_format ( max_terms = 3 )","title":"Units"},{"location":"customize/#raw-time-fields","text":"You can access the raw (floating point) values of the time aggregates as keys in the format string as well. These are all recorded in nanoseconds (unless you specified a different timer function): avg_time_ns :the average of all past time intervals std_time_ns : the standard deviation of all past time intervals min_time_ns : the minimum measured time max_time_ns : the maximum measured time last_time_ns : the last measured time","title":"Raw time fields"},{"location":"customize/#updated-lines","text":"By default, ticktock attempts to update the last clock lines it has displayed with the new values. However, it can be undesirable in some instandes: - it can fail if other things are being written to the stream (e.g. using print in the code, or using tqdm ), or delete printed messages - it uses ASCII contol chars, which may be unwelcome if you are writing to a file If you want ticktock to write all clocks sequentially, without attempting to update previously renderered lines, set the format with no_update=True : from ticktock import set_format set_format ( no_update = True )","title":"Updated lines"},{"location":"customize/#change-rendering-period","text":"By default, ticktock renders clocks with a fixed period of two seconds. This can be changed globally by using set_period : from ticktock import tick set_period ( 1 ) Internally, ticktock will render all clocks whenever the period is elapsed, and a clock's tock was called. In addition to this, rendering also occurs: at the first tock of any clock when the program exits","title":"Change rendering period"},{"location":"customize/#enabling-or-disabling-clocks","text":"It is possible to disable ticktock clocks: when disabled, the intervals between ticks and tocks are no longer recorded, and will not be rendered either.","title":"Enabling or disabling clocks"},{"location":"customize/#with-an-environment-variable","text":"Set the TICKTOCK_DISABLE environment variable to disable all clocks and their rendering.","title":"With an environment variable"},{"location":"customize/#with-enabledisable","text":"ticktock also provide functions to enable or disable all clocks (and rendering): from ticktock import tick , enable , disable def some_function (): t = tick () pass t . tock () # This call will be timed and collected some_function () disable () # This call will NOT be timed some_function () enable () # This call will be timed again some_function () Warn enable and disable act on the current default ClockCollection (as set by set_collection )","title":"With enable/disable"},{"location":"customize/#disabling-a-clock-vs-disabling-a-clockcollection","text":"Warn This is an advanced topic, and should not occur unless you set the enabled/disabled state of Clock objects directly. Both Clock and ClockCollection objects can be enabled or disabled independently via their enable / disable methods. This can be misleading if a Clock 's state does not match its ClockCollection state. Simply put, here are the gotchas: a disabled Clock will not record any timing information, but if its ClockCollection is enabled, its state will be rendered disabling and enabling a ClockCollection will set the state of all of the Clock s that are currently attached to it disabling a clock does not disable its ClockCollection","title":"Disabling a Clock vs. disabling a ClockCollection"},{"location":"rendering/","text":"Advanced rendering \u00b6 This section describes how to specify the exact renderer objects used by ticktock : A StandardRenderer to print to a file, or even more control on the output A LoggingRenderer to send log messages Specifying a renderer \u00b6 In ticktock , each ticktock ClockCollection object has a renderer attribute that controls how the clocks are rendered. Create your own ClockCollection with a custom renderer to customiwe the way ticktock renders your clocks. Then, set it as the default collection so all your tick s and tock s are attached to it: from ticktock.timer import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( renderer = renderers . StandardRenderer ()) set_collection ( collection = collection ) Standard renderer \u00b6 The StandardRenderer is used by default and prints to stdout: StandardRenderer ( format : Optional [ str ] = None , out : TextIO = sys . stderr , max_terms : int = 2 ) format is a regular Python format string describing the desired output. See format strings out is a text IO stream to write to max_terms controls the number of units to display. 1.3 seconds will be written as 1s with max_terms = 1 or 1s300ms with max_terms = 2 Logging renderer \u00b6 The LoggingRenderer is used to render timing information as log messages instead of printing: LoggingRenderer ( logger = None , level : str = \"INFO\" , extra_as_kwargs : bool = False ) This will make ticktock render all statistics as log messages of the given log level. Statistics are passed as a dictionary to the extra attribute of the logger by default. As a result you should make sure that your logging handler and formatter correctly outputs the contents of the extra dictionary. If your logger accepts keyword arguments to the logging functions (for example with structlog ), provide your own logger and set extra_as_kwargs to True .","title":"Renderer"},{"location":"rendering/#advanced-rendering","text":"This section describes how to specify the exact renderer objects used by ticktock : A StandardRenderer to print to a file, or even more control on the output A LoggingRenderer to send log messages","title":"Advanced rendering"},{"location":"rendering/#specifying-a-renderer","text":"In ticktock , each ticktock ClockCollection object has a renderer attribute that controls how the clocks are rendered. Create your own ClockCollection with a custom renderer to customiwe the way ticktock renders your clocks. Then, set it as the default collection so all your tick s and tock s are attached to it: from ticktock.timer import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( renderer = renderers . StandardRenderer ()) set_collection ( collection = collection )","title":"Specifying a renderer"},{"location":"rendering/#standard-renderer","text":"The StandardRenderer is used by default and prints to stdout: StandardRenderer ( format : Optional [ str ] = None , out : TextIO = sys . stderr , max_terms : int = 2 ) format is a regular Python format string describing the desired output. See format strings out is a text IO stream to write to max_terms controls the number of units to display. 1.3 seconds will be written as 1s with max_terms = 1 or 1s300ms with max_terms = 2","title":"Standard renderer"},{"location":"rendering/#logging-renderer","text":"The LoggingRenderer is used to render timing information as log messages instead of printing: LoggingRenderer ( logger = None , level : str = \"INFO\" , extra_as_kwargs : bool = False ) This will make ticktock render all statistics as log messages of the given log level. Statistics are passed as a dictionary to the extra attribute of the logger by default. As a result you should make sure that your logging handler and formatter correctly outputs the contents of the extra dictionary. If your logger accepts keyword arguments to the logging functions (for example with structlog ), provide your own logger and set extra_as_kwargs to True .","title":"Logging renderer"},{"location":"using_clocks/","text":"Advanced timing \u00b6 ticktock gives you different ways to specify which parts of your code you want to time: functions, a decorator, or a context manager. tick and tock \u00b6 Use tick to create a Clock and signal the start of a measurement: from ticktock import tick t = tick () # t is a Clock instance Then, use the tock method to signal the end of the measurement for this clock: t . tock () Info tick and tock function by recording the specific line in your code that they are created at. This allows ticktock to aggregate times together although the Clock is redefined everytime the code is visited: for _ in range ( 100 ): t = tick () # <- this is always the same object ... t . tock () id ( t ) # <- this is always the same value Context manager \u00b6 It is possible to use ticktock as a context manager to track the timing of a chunk of code: from ticktock import ticktock with ticktock (): time . sleep ( 1 ) Function decorator \u00b6 ticktock doubles as a decorator that tracks the timing of each call to a function: from ticktock import ticktock @ticktock def f (): time . sleep ( 1 ) f () Timer names \u00b6 By default, tick creates a clock named after where it is first created (e.g. path/to/the/code.py:line_number ), and tock is named after the line in which it is called. As a result, a Clock is typically renderer as path/to/the/code.py:start-stop where start and stop are the line numnbers of the tick and tock . Explicit clock naming \u00b6 It is possible to explicitly name the beginning (\"tick\") and the end (\"tock\") of timers as so from ticktock import tick clock = tick ( \"beginning\" ) clock . tock ( \"end\" ) Which will then be displayed as \u23f1\ufe0f [beginning-end] 1ms count=1 Multiple Clocks \u00b6 Of course, can create multiple independent ticks, which will appear as separate clocks: for _ in range ( 1000 ): clock = tick () # do some work time . sleep ( 1 ) clock . tock () clock = tick () # do some other work time . sleep ( 0.5 ) clock . tock () Multiple Clock end times \u00b6 More subtlely, a clock can have a multiple tocks , which will be displayed as different lines for k in range ( 1000 ): t = tick () # do some work time . sleep ( 1 ) if k % 2 == 1 : time . sleep ( 1 ) t . tock () else : t . tock ()","title":"Using clocks"},{"location":"using_clocks/#advanced-timing","text":"ticktock gives you different ways to specify which parts of your code you want to time: functions, a decorator, or a context manager.","title":"Advanced timing"},{"location":"using_clocks/#tick-and-tock","text":"Use tick to create a Clock and signal the start of a measurement: from ticktock import tick t = tick () # t is a Clock instance Then, use the tock method to signal the end of the measurement for this clock: t . tock () Info tick and tock function by recording the specific line in your code that they are created at. This allows ticktock to aggregate times together although the Clock is redefined everytime the code is visited: for _ in range ( 100 ): t = tick () # <- this is always the same object ... t . tock () id ( t ) # <- this is always the same value","title":"tick and tock"},{"location":"using_clocks/#context-manager","text":"It is possible to use ticktock as a context manager to track the timing of a chunk of code: from ticktock import ticktock with ticktock (): time . sleep ( 1 )","title":"Context manager"},{"location":"using_clocks/#function-decorator","text":"ticktock doubles as a decorator that tracks the timing of each call to a function: from ticktock import ticktock @ticktock def f (): time . sleep ( 1 ) f ()","title":"Function decorator"},{"location":"using_clocks/#timer-names","text":"By default, tick creates a clock named after where it is first created (e.g. path/to/the/code.py:line_number ), and tock is named after the line in which it is called. As a result, a Clock is typically renderer as path/to/the/code.py:start-stop where start and stop are the line numnbers of the tick and tock .","title":"Timer names"},{"location":"using_clocks/#explicit-clock-naming","text":"It is possible to explicitly name the beginning (\"tick\") and the end (\"tock\") of timers as so from ticktock import tick clock = tick ( \"beginning\" ) clock . tock ( \"end\" ) Which will then be displayed as \u23f1\ufe0f [beginning-end] 1ms count=1","title":"Explicit clock naming"},{"location":"using_clocks/#multiple-clocks","text":"Of course, can create multiple independent ticks, which will appear as separate clocks: for _ in range ( 1000 ): clock = tick () # do some work time . sleep ( 1 ) clock . tock () clock = tick () # do some other work time . sleep ( 0.5 ) clock . tock ()","title":"Multiple Clocks"},{"location":"using_clocks/#multiple-clock-end-times","text":"More subtlely, a clock can have a multiple tocks , which will be displayed as different lines for k in range ( 1000 ): t = tick () # do some work time . sleep ( 1 ) if k % 2 == 1 : time . sleep ( 1 ) t . tock () else : t . tock ()","title":"Multiple Clock end times"}]}